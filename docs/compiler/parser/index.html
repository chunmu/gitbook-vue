
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>parser · Blankj's Glory</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Blankj">
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    

        
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    
    <link rel="prev" href="../" />
    

    
        <link rel="shortcut icon" href='../../source/images/favicon.jpg' type="image/x-icon">
    
    
        <link rel="bookmark" href='../../source/images/favicon.jpg' type="image/x-icon">
    
    
        <link rel="apple-touch-icon" href='../../source/images/apple-touch-icon.jpg'>
    
    
        
        <link rel="apple-touch-icon" sizes="120x120" href="../../source/images/apple-touch-icon.jpg">
        
        <link rel="apple-touch-icon" sizes="180x180" href="../../source/images/apple-touch-icon.jpg">
        
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../">
            
                <a href="../">
            
                    
                    compiler
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.2.1" data-path="./">
            
                <a href="./">
            
                    
                    parser
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.2.1.1" data-path="./">
            
                <a href="./">
            
                    
                    index
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" data-path="html-parser.html">
            
                <a href="html-parser.html">
            
                    
                    html-parser
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="filter-parser.html">
            
                <a href="filter-parser.html">
            
                    
                    filter-parser
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../directives/index.md">
            
                <span>
            
                    
                    directives
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="../directives/model.html">
            
                <a href="../directives/model.html">
            
                    
                    model
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../helpers.html">
            
                <a href="../helpers.html">
            
                    
                    helpers
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >parser</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="parser">parser</h1>
<h2 id="&#x6D41;&#x7A0B;&#x56FE;">&#x6D41;&#x7A0B;&#x56FE;</h2>
<p><img src="https://chunmu.github.io/gitbook-vue/assets/pictures/compiler-parser-index.jpg" alt="&#x7F16;&#x8BD1;html&#x7684;&#x6D41;&#x7A0B;&#x56FE;" title="&#x7F16;&#x8BD1;html&#x7684;&#x6D41;&#x7A0B;&#x56FE;"></p>
<h3 id="createastelement">createASTElement</h3>
<blockquote>
<p>&#x5173;&#x4E8E;AST&#x8BED;&#x6CD5;&#x6811; &#x8BF7;&#x67E5;&#x9605;<a href="https://juejin.im/post/5bff941e5188254e3b31b424" title="&#x6398;&#x91D1;AST&#x8BED;&#x6CD5;&#x6811;" target="_blank">&#x6398;&#x91D1;AST&#x8BED;&#x6CD5;&#x6811;</a></p>
</blockquote>
<pre><code class="lang-javascript">
<span class="hljs-comment">// &#x8FD9;&#x5C31;&#x662F;&#x6211;&#x4EEC;parser&#x8F93;&#x51FA;&#x7684;&#x4E00;&#x9879;&#x91CD;&#x8981;&#x5185;&#x5BB9;</span>
<span class="hljs-comment">// &#x521B;&#x5EFA;AST&#x8BED;&#x6CD5;&#x6811;&#x8282;&#x70B9;&#x4FE1;&#x606F;  &#x628A;html&#x6807;&#x7B7E;&#x5143;&#x7D20;&#x7684;&#x5C42;&#x7EA7;&#x5173;&#x7CFB;&#x8868;&#x73B0;&#x4E3A;ast&#x8282;&#x70B9;&#x7684;&#x6811;&#x5F62;&#x5173;&#x7CFB;</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createASTElement</span> (<span class="hljs-params">
  tag: string,
  attrs: Array&lt;ASTAttr&gt;,
  parent: ASTElement | void
</span>): <span class="hljs-title">ASTElement</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">1</span>,
    tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent,
    children: []
  }
}
</code></pre>
<h3 id="parse">parse</h3>
<blockquote>
<p>parser&#x6838;&#x5FC3;&#x5165;&#x53E3;</p>
</blockquote>
<pre><code class="lang-javascript">
<span class="hljs-comment">/**
 * Convert HTML string to AST.
 * &#x8F6C;&#x6362;html&#x6210;ast&#x8BED;&#x6CD5;&#x6811;
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">
  template: string,
  options: CompilerOptions
</span>): <span class="hljs-title">ASTElement</span> | <span class="hljs-title">void</span> </span>{
  warn = options.warn || baseWarn
  platformIsPreTag = options.isPreTag || no <span class="hljs-comment">// &lt;pre&gt;&#x6807;&#x7B7E;&#x76F8;&#x5173;</span>
  <span class="hljs-comment">// &#x662F;&#x5426;&#x5FC5;&#x987B;&#x52A0;&#x5165;el.props  &#x5FC5;&#x987B;&#x63A5;&#x6536;</span>
  platformMustUseProp = options.mustUseProp || no <span class="hljs-comment">// &#x662F;&#x5426;&#x4E3A;&#x5FC5;&#x987B;&#x653E;&#x7F6E;&#x5230;props&#x4E2D;&#x7684;&#x5C5E;&#x6027;</span>
  platformGetTagNamespace = options.getTagNamespace || no <span class="hljs-comment">// &#x83B7;&#x53D6;&#x547D;&#x540D;&#x7A7A;&#x95F4; &#x6709;&#x4E9B;&#x6807;&#x7B7E;&#x662F;&#x5E26;&#x6709;&#x547D;&#x540D;&#x7A7A;&#x95F4;&#x5C5E;&#x6027;&#x7684;  &#x6BD4;&#x5982; &lt;svg&gt;  &lt;frame&gt;</span>
  <span class="hljs-keyword">const</span> isReservedTag = options.isReservedTag || no <span class="hljs-comment">// &#x662F;&#x5426;&#x4E3A;&#x4FDD;&#x7559;tag</span>
  maybeComponent = (el: ASTElement) =&gt; !!el.component || !isReservedTag(el.tag)

  transforms = pluckModuleFunction(options.modules, <span class="hljs-string">&apos;transformNode&apos;</span>)
  preTransforms = pluckModuleFunction(options.modules, <span class="hljs-string">&apos;preTransformNode&apos;</span>)
  postTransforms = pluckModuleFunction(options.modules, <span class="hljs-string">&apos;postTransformNode&apos;</span>)

  <span class="hljs-comment">// &#x9ED8;&#x8BA4;&#x503C; [&quot;{{&quot;, &quot;}}&quot;]   delimiters: [&apos;${&apos;, &apos;}&apos;]  &#x6539;&#x53D8;&#x7EAF;&#x6587;&#x672C;&#x63D2;&#x5165;&#x5206;&#x9694;&#x7B26;</span>
  delimiters = options.delimiters

  <span class="hljs-keyword">const</span> stack = []
  <span class="hljs-keyword">const</span> preserveWhitespace = options.preserveWhitespace !== <span class="hljs-literal">false</span>
  <span class="hljs-keyword">const</span> whitespaceOption = options.whitespace
  <span class="hljs-comment">// &#x521B;&#x5EFA;stack,root,currentParent</span>
  <span class="hljs-comment">/**
  * root&#xFF0C;stack&#x7684;&#x7528;&#x6CD5;&#x8BE6;&#x89E3;
  * 1. &#x5224;&#x65AD;&#x5F53;&#x524D;root&#x662F;&#x5426;&#x5DF2;&#x5B58;&#x5728; &#x4E0D;&#x5B58;&#x5728;&#x5219;&#x5728;parseHTML&#x4E2D;start&#x8C03;&#x7528;&#x8D4B;&#x503C;root  &#x4F5C;&#x4E3A;&#x6574;&#x4E2A;compier&#x7684;&#x6839;&#x8282;&#x70B9;
  * 2. currentParent&#x5728;start&#x4E2D;  &#x5982;&#x679C;&#x4F20;&#x5165;&#x8FDB;&#x6765;&#x7684;&#x4E0D;&#x662F;&#x81EA;&#x95ED;&#x5408;&#x6807;&#x7B7E; &#x5219;&#x4F5C;&#x4E3A;&#x5F53;&#x524D;&#x7236;&#x7EA7;&#x8282;&#x70B9;  &lt;div1&gt;&lt;div2&gt;&lt;img&gt;&lt;/div2&gt;&lt;/div1&gt; 
  * 3. start() &#x7B2C;&#x4E00;&#x4E2A;&#x56DE;&#x5408; root = div1 currentParent = div1  
  * 4. start() &#x7B2C;&#x4E8C;&#x4E2A;&#x56DE;&#x5408; &#x5DF2;&#x5B58;&#x5728;&#x6839;&#x8282;&#x70B9;root &#x6709;&#x4E14;&#x53EA;&#x80FD;&#x6709;&#x4E00;&#x4E2A;  currentParent = div2
  * 5. start() &#x7B2C;&#x4E09;&#x4E2A;&#x56DE;&#x5408; img&#x662F;&#x81EA;&#x95ED;&#x5408;&#x6807;&#x7B7E;  currentParent&#x4E0D;&#x53D8;
  * 6. end() &#x7B2C;&#x56DB;&#x4E2A;&#x56DE;&#x5408; &#x5904;&#x7406;&#x6389;&#x4E00;&#x4E2A;stack  stack.length - 1 currentParent = div1
  * */</span>
  <span class="hljs-keyword">let</span> root
  <span class="hljs-keyword">let</span> currentParent
  <span class="hljs-comment">// https://cn.vuejs.org/v2/api/#v-pre</span>
  <span class="hljs-comment">// &#x5982;&#x679C;&#x662F;&#x5728;v-pre&#x6307;&#x4EE4;&#x4E2D; &#x4E0D;&#x7F16;&#x8BD1; &#x5C5E;&#x6027;&#x503C;stringify&#x8F93;&#x51FA;</span>
  <span class="hljs-comment">// &#x5982;&#x679C;&#x5728;v-pre&#x6807;&#x7B7E;&#x91CC;&#x9762;  &#x5219;&#x4E0D;&#x8FDB;&#x884C;&#x7F16;&#x8BD1;&#x5904;&#x7406;  &#x5C5E;&#x6027;&#x503C;&#x90FD;&#x4F7F;&#x7528;stringify&#x5904;&#x7406;</span>
  <span class="hljs-keyword">let</span> inVPre = <span class="hljs-literal">false</span>
  <span class="hljs-comment">// pre&#x6807;&#x7B7E;  &#x4EE3;&#x7801;&#x6807;&#x7B7E; </span>
  <span class="hljs-keyword">let</span> inPre = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">let</span> warned = <span class="hljs-literal">false</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnce</span> (<span class="hljs-params">msg, range</span>) </span>{
    <span class="hljs-keyword">if</span> (!warned) {
      warned = <span class="hljs-literal">true</span>
      warn(msg, range)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeElement</span> (<span class="hljs-params">element</span>) </span>{
    trimEndingWhitespace(element)
    <span class="hljs-keyword">if</span> (!inVPre &amp;&amp; !element.processed) {
      element = processElement(element, options)
    }
    <span class="hljs-comment">// tree management</span>
    <span class="hljs-keyword">if</span> (!stack.length &amp;&amp; element !== root) {
      <span class="hljs-comment">// allow root elements with v-if, v-else-if and v-else</span>
      <span class="hljs-keyword">if</span> (root.if &amp;&amp; (element.elseif || element.else)) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          checkRootConstraints(element)
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        })
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
        warnOnce(
          <span class="hljs-string">`Component template should contain exactly one root element. `</span> +
          <span class="hljs-string">`If you are using v-if on multiple elements, `</span> +
          <span class="hljs-string">`use v-else-if to chain them instead.`</span>,
          { start: element.start }
        )
      }
    }
    <span class="hljs-keyword">if</span> (currentParent &amp;&amp; !element.forbidden) {
      <span class="hljs-keyword">if</span> (element.elseif || element.else) {
        processIfConditions(element, currentParent)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (element.slotScope) {
          <span class="hljs-comment">// scoped slot</span>
          <span class="hljs-comment">// keep it in the children list so that v-else(-if) conditions can</span>
          <span class="hljs-comment">// find it as the prev node.</span>
          <span class="hljs-keyword">const</span> name = element.slotTarget || <span class="hljs-string">&apos;&quot;default&quot;&apos;</span>
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
        }
        currentParent.children.push(element)
        element.parent = currentParent
      }
    }

    <span class="hljs-comment">// final children cleanup</span>
    <span class="hljs-comment">// filter out scoped slots</span>
    element.children = element.children.filter(c =&gt; !(c: any).slotScope)
    <span class="hljs-comment">// remove trailing whitespace node again</span>
    trimEndingWhitespace(element)

    <span class="hljs-comment">// check pre state</span>
    <span class="hljs-keyword">if</span> (element.pre) {
      inVPre = <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> (platformIsPreTag(element.tag)) {
      inPre = <span class="hljs-literal">false</span>
    }
    <span class="hljs-comment">// apply post-transforms</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; postTransforms.length; i++) {
      postTransforms[i](element, options)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimEndingWhitespace</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-comment">// remove trailing whitespace node</span>
    <span class="hljs-comment">// &#x6E05;&#x9664;&#x672B;&#x5C3E;&#x591A;&#x4F59;&#x7684;&#x7A7A;&#x683C;</span>
    <span class="hljs-keyword">if</span> (!inPre) {
      <span class="hljs-keyword">let</span> lastNode
      <span class="hljs-keyword">while</span> (
        (lastNode = el.children[el.children.length - <span class="hljs-number">1</span>]) &amp;&amp;
        lastNode.type === <span class="hljs-number">3</span> &amp;&amp;
        lastNode.text === <span class="hljs-string">&apos; &apos;</span>
      ) {
        el.children.pop()
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkRootConstraints</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x4EE5;slot&#x6216;&#x8005;template&#x4F5C;&#x4E3A;&#x6839;&#x5143;&#x7D20;</span>
    <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;slot&apos;</span> || el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
      warnOnce(
        <span class="hljs-string">`Cannot use &lt;<span class="hljs-subst">${el.tag}</span>&gt; as component root element because it may `</span> +
        <span class="hljs-string">&apos;contain multiple nodes.&apos;</span>,
        { start: el.start }
      )
    }
    <span class="hljs-comment">// &#x6839;&#x5143;&#x7D20;&#x4E0D;&#x80FD;&#x6709;v-for&#x6307;&#x4EE4;</span>
    <span class="hljs-keyword">if</span> (el.attrsMap.hasOwnProperty(<span class="hljs-string">&apos;v-for&apos;</span>)) {
      warnOnce(
        <span class="hljs-string">&apos;Cannot use v-for on stateful component root element because &apos;</span> +
        <span class="hljs-string">&apos;it renders multiple elements.&apos;</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]
      )
    }
  }

  parseHTML(template, {
    warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start (tag, attrs, unary, start, end) {
      <span class="hljs-comment">// check namespace.</span>
      <span class="hljs-comment">// inherit parent ns if there is one</span>
      <span class="hljs-comment">// &#x5F00;&#x59CB;&#x751F;&#x6210;ast&#x8BED;&#x6CD5;&#x6811;</span>
      <span class="hljs-comment">// &#x547D;&#x540D;&#x7A7A;&#x95F4;&#x76F8;&#x5173;  &#x6709;&#x4E9B;&#x6807;&#x7B7E;&#x662F;&#x6709;&#x8FD9;&#x4E2A;&#x5C5E;&#x6027;&#x7684;  &#x6BD4;&#x5982; svg frame&#x7B49;</span>
      <span class="hljs-keyword">const</span> ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag)

      <span class="hljs-comment">// handle IE svg bug</span>
      <span class="hljs-comment">/* istanbul ignore if */</span>
      <span class="hljs-keyword">if</span> (isIE &amp;&amp; ns === <span class="hljs-string">&apos;svg&apos;</span>) {
        attrs = guardIESVGBug(attrs)
      }
      <span class="hljs-comment">// &#x751F;&#x6210;ast&#x8282;&#x70B9;</span>
      <span class="hljs-keyword">let</span> element: ASTElement = createASTElement(tag, attrs, currentParent)
      <span class="hljs-comment">// &#x6269;&#x5C55; ns</span>
      <span class="hljs-keyword">if</span> (ns) {
        element.ns = ns
      }

      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
        <span class="hljs-keyword">if</span> (options.outputSourceRange) {
          element.start = start
          element.end = end
          element.rawAttrsMap = element.attrsList.reduce((cumulated, attr) =&gt; {
            cumulated[attr.name] = attr
            <span class="hljs-keyword">return</span> cumulated
          }, {})
        }
        <span class="hljs-comment">// &#x6821;&#x9A8C;&#x5C5E;&#x6027;&#x540D;&#x79F0;&#x7684;&#x5408;&#x6CD5;&#x6027;</span>
        attrs.forEach(attr =&gt; {
          <span class="hljs-comment">// const invalidAttributeRE = /[\s&quot;&apos;&lt;&gt;\/=]/</span>
          <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x5305;&#x542B;&#x4E0A;&#x9762;&#x8FD9;&#x4E9B;&#x7279;&#x6B8A;&#x5B57;&#x7B26;</span>
          <span class="hljs-keyword">if</span> (invalidAttributeRE.test(attr.name)) {
            warn(
              <span class="hljs-string">`Invalid dynamic argument expression: attribute names cannot contain `</span> +
              <span class="hljs-string">`spaces, quotes, &lt;, &gt;, / or =.`</span>,
              {
                start: attr.start + attr.name.indexOf(<span class="hljs-string">`[`</span>),
                end: attr.start + attr.name.length
              }
            )
          }
        })
      }
      <span class="hljs-comment">// &#x6709;&#x526F;&#x4F5C;&#x7528;&#x7684;&#x6807;&#x7B7E;  dom&#x4E2D;&#x653E;&#x5165;script&#x5728;&#x6D4F;&#x89C8;&#x5668;&#x7406;&#x8BBA;&#x4E0A;&#x662F;&#x5408;&#x6CD5;&#x7684;  &#x4E0D;&#x8FC7;&#x5728;vue&#x4E2D;&#x4E3A;&#x907F;&#x514D;&#x4E0D;&#x53EF;&#x63A7;&#x7684;&#x98CE;&#x9669; &#x7981;&#x6B62;&#x8FD9;&#x6837;&#x505A;</span>
      <span class="hljs-comment">// &#x670D;&#x52A1;&#x5668;&#x7AEF;&#x6E32;&#x67D3;&#x7684;&#x53EF;&#x4EE5;&#x8FD9;&#x6837;&#x653E;  &#x4E0D;&#x5927;&#x660E;&#x767D;&#x4E3A;&#x5565;</span>
      <span class="hljs-keyword">if</span> (isForbiddenTag(element) &amp;&amp; !isServerRendering()) {
        element.forbidden = <span class="hljs-literal">true</span>
        process.env.NODE_ENV !== <span class="hljs-string">&apos;&apos;</span> +
        <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; warn(
          <span class="hljs-string">&apos;Templates should only be responsible for mapping the state to the &apos;</span> +
          <span class="hljs-string">&apos;UI. Avoid placing tags with side-effects in your templates, such as &apos;</span> +
          <span class="hljs-string">`&lt;<span class="hljs-subst">${tag}</span>&gt;`</span> + <span class="hljs-string">&apos;, as they will not be parsed.&apos;</span>,
          { start: element.start }
        )
      }

      <span class="hljs-comment">// apply pre-transforms</span>
      <span class="hljs-comment">// &#x5728;&#x5904;&#x7406;pre&#x6307;&#x4EE4;&#x4E4B;&#x524D;&#x7684;&#x524D;&#x7F6E;&#x5DE5;&#x4F5C;</span>
      <span class="hljs-comment">// &#x5148;&#x653E;&#x7740;  &#x5904;&#x7406;&#x542B;&#x6709;v-model&#x7684;input&#x6807;&#x7B7E;</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element
      }


      <span class="hljs-comment">// &#x67E5;&#x770B;&#x662F;&#x5426;&#x5728;v-pre&#x4E2D;  &#x5982;&#x679C;&#x662F;&#x5728;v-pre&#x4E2D; &#x5219;&#x8DF3;&#x8FC7;&#x5927;&#x91CF;&#x7684;&#x4E0D;&#x7528;&#x7F16;&#x8BD1;&#x7684;&#x6A21;&#x677F;</span>
      <span class="hljs-keyword">if</span> (!inVPre) {
        processPre(element)
        <span class="hljs-keyword">if</span> (element.pre) {
          inVPre = <span class="hljs-literal">true</span>
        }
      }
      <span class="hljs-keyword">if</span> (platformIsPreTag(element.tag)) {
        inPre = <span class="hljs-literal">true</span>
      }
      <span class="hljs-keyword">if</span> (inVPre) {
        <span class="hljs-comment">// &#x5982;&#x679C;&#x5728;v-pre&#x4E2D; &#x5219;&#x9700;&#x8981;&#x5BF9;attrs&#x8FDB;&#x884C;&#x5904;&#x7406; &#x628A;&#x503C;&#x8FDB;&#x884C;stringify</span>
        <span class="hljs-comment">// &#x6CA1;&#x6709;attrs&#x7684;&#x8BDD;  &#x7EAF;&#x51C0;&#x6734;&#x7D20;&#x7684;&#x5143;&#x7D20;  element.plain = true</span>
        processRawAttrs(element)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!element.processed) {
        <span class="hljs-comment">// structural directives</span>
        <span class="hljs-comment">// &#x7ED3;&#x6784;&#x6307;&#x4EE4;&#x5904;&#x7406;</span>
        processFor(element)
        processIf(element)
        processOnce(element)
      }

      <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x4E0D;&#x5B58;&#x5728;root&#x5143;&#x7D20;  &#x5219;&#x6700;&#x5148;&#x5904;&#x7406;&#x7684;&#x8D4B;&#x503C;&#x7ED9;root</span>
      <span class="hljs-keyword">if</span> (!root) {
        root = element
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          checkRootConstraints(root)
        }
      }

      <span class="hljs-keyword">if</span> (!unary) {
        <span class="hljs-comment">// &#x6E38;&#x6807;&#x6307;&#x5411;element</span>
        currentParent = element
        <span class="hljs-comment">// &#x975E;&#x81EA;&#x95ED;&#x5408;&#x7684;&#x6807;&#x7B7E;elpush&#x5230;stack</span>
        stack.push(element)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// &#x81EA;&#x95ED;&#x5408;&#x6807;&#x7B7E;&#x4F1A;&#x5728;&#x8FD9;&#x8FB9;&#x5C31;&#x8C03;&#x7528;close&#x5904;&#x7406;</span>
        closeElement(element)
      }
    },

    end (tag, start, end) {
      <span class="hljs-comment">// &#x5339;&#x914D;&#x5230;&#x7ED3;&#x675F;&#x6807;&#x7B7E;  &#x5BF9;&#x5E94;&#x7684;&#x83B7;&#x53D6;stack.length - 1&#x5C31;&#x662F;&#x5B83;&#x5BF9;&#x5E94;&#x7684;el</span>
      <span class="hljs-keyword">const</span> element = stack[stack.length - <span class="hljs-number">1</span>]
      <span class="hljs-comment">// pop stack</span>
      stack.length -= <span class="hljs-number">1</span>
      <span class="hljs-comment">// currentParent &#x5411;&#x4E0A;&#x5192;&#x6CE1;&#x4E00;&#x5C42;</span>
      currentParent = stack[stack.length - <span class="hljs-number">1</span>]
      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; options.outputSourceRange) {
        element.end = end
      }
      closeElement(element)
    },

    chars (text: string, start: number, end: number) {
      <span class="hljs-keyword">if</span> (!currentParent) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          <span class="hljs-keyword">if</span> (text === template) {
            warnOnce(
              <span class="hljs-string">&apos;Component template requires a root element, rather than just text.&apos;</span>,
              { start }
            )
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((text = text.trim())) {
            warnOnce(
              <span class="hljs-string">`text &quot;<span class="hljs-subst">${text}</span>&quot; outside root element will be ignored.`</span>,
              { start }
            )
          }
        }
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-comment">// IE textarea placeholder bug</span>
      <span class="hljs-comment">/* istanbul ignore if */</span>
      <span class="hljs-keyword">if</span> (isIE &amp;&amp;
        currentParent.tag === <span class="hljs-string">&apos;textarea&apos;</span> &amp;&amp;
        currentParent.attrsMap.placeholder === text
      ) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-keyword">const</span> children = currentParent.children
      <span class="hljs-keyword">if</span> (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!children.length) {
        <span class="hljs-comment">// remove the whitespace-only node right after an opening tag</span>
        text = <span class="hljs-string">&apos;&apos;</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (whitespaceOption) {
        <span class="hljs-keyword">if</span> (whitespaceOption === <span class="hljs-string">&apos;condense&apos;</span>) {
          <span class="hljs-comment">// in condense mode, remove the whitespace node if it contains</span>
          <span class="hljs-comment">// line break, otherwise condense to a single space</span>
          text = lineBreakRE.test(text) ? <span class="hljs-string">&apos;&apos;</span> : <span class="hljs-string">&apos; &apos;</span>
        } <span class="hljs-keyword">else</span> {
          text = <span class="hljs-string">&apos; &apos;</span>
        }
      } <span class="hljs-keyword">else</span> {
        text = preserveWhitespace ? <span class="hljs-string">&apos; &apos;</span> : <span class="hljs-string">&apos;&apos;</span>
      }
      <span class="hljs-keyword">if</span> (text) {
        <span class="hljs-keyword">if</span> (!inPre &amp;&amp; whitespaceOption === <span class="hljs-string">&apos;condense&apos;</span>) {
          <span class="hljs-comment">// condense consecutive whitespaces into single space</span>
          text = text.replace(whitespaceRE, <span class="hljs-string">&apos; &apos;</span>)
        }
        <span class="hljs-keyword">let</span> res
        <span class="hljs-keyword">let</span> child: ?ASTNode
        <span class="hljs-keyword">if</span> (!inVPre &amp;&amp; text !== <span class="hljs-string">&apos; &apos;</span> &amp;&amp; (res = parseText(text, delimiters))) {
          child = {
            type: <span class="hljs-number">2</span>,
            expression: res.expression,
            tokens: res.tokens,
            text
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (text !== <span class="hljs-string">&apos; &apos;</span> || !children.length || children[children.length - <span class="hljs-number">1</span>].text !== <span class="hljs-string">&apos; &apos;</span>) {
          child = {
            type: <span class="hljs-number">3</span>,
            text
          }
        }
        <span class="hljs-keyword">if</span> (child) {
          <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; options.outputSourceRange) {
            child.start = start
            child.end = end
          }
          children.push(child)
        }
      }
    },
    comment (text: string, start, end) {
      <span class="hljs-comment">// adding anyting as a sibling to the root node is forbidden</span>
      <span class="hljs-comment">// comments should still be allowed, but ignored</span>
      <span class="hljs-keyword">if</span> (currentParent) {
        <span class="hljs-keyword">const</span> child: ASTText = {
          type: <span class="hljs-number">3</span>,
          text,
          isComment: <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; options.outputSourceRange) {
          child.start = start
          child.end = end
        }
        currentParent.children.push(child)
      }
    }
  })
  <span class="hljs-built_in">console</span>.log(root, <span class="hljs-string">&apos;root&apos;</span>)
  <span class="hljs-keyword">return</span> root
}
</code></pre>
<h3 id="processfor">processFor</h3>
<pre><code class="lang-javascript">
<span class="hljs-comment">// &#x6302;&#x8F7D;el.for el.alias  el.iterator  el.ex&#x7B49;</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFor</span> (<span class="hljs-params">el: ASTElement</span>) </span>{
  <span class="hljs-keyword">let</span> exp
  <span class="hljs-keyword">if</span> ((exp = getAndRemoveAttr(el, <span class="hljs-string">&apos;v-for&apos;</span>))) {
    <span class="hljs-keyword">const</span> res = parseFor(exp)
    <span class="hljs-keyword">if</span> (res) {
      extend(el, res)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
      warn(
        <span class="hljs-string">`Invalid v-for expression: <span class="hljs-subst">${exp}</span>`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]
      )
    }
  }
}
</code></pre>
<h3 id="parsefor">parseFor</h3>
<pre><code class="lang-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFor</span> (<span class="hljs-params">exp: string</span>): ?<span class="hljs-title">ForParseResult</span> </span>{

  <span class="hljs-keyword">const</span> inMatch = exp.match(forAliasRE)
  <span class="hljs-keyword">if</span> (!inMatch) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">const</span> res = {}
  res.for = inMatch[<span class="hljs-number">2</span>].trim()
  <span class="hljs-keyword">const</span> alias = inMatch[<span class="hljs-number">1</span>].trim().replace(stripParensRE, <span class="hljs-string">&apos;&apos;</span>)
  <span class="hljs-comment">// v-for=&quot;item, index in 8&quot;   alias = &quot;item, index&quot;</span>
  <span class="hljs-comment">// v-for=&quot;item in 8&quot;  alias=&quot;item&quot;</span>
  <span class="hljs-comment">// &#x65E0;&#x8BBA;&#x56FE;&#x548C; &#x6700;&#x540E;parse&#x540E;&#x7684;&#x7ED3;&#x679C; res.alias = item</span>
  <span class="hljs-comment">//  /,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span>
  <span class="hljs-keyword">const</span> iteratorMatch = alias.match(forIteratorRE)
  <span class="hljs-keyword">if</span> (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, <span class="hljs-string">&apos;&apos;</span>).trim() <span class="hljs-comment">// &#x5BF9;&#x5E94;&#x7684;v-for=&quot;item, index in obj&quot;  &#x5BF9;&#x5E94;&#x7684;&#x662F; alias = item</span>
    res.iterator1 = iteratorMatch[<span class="hljs-number">1</span>].trim()  <span class="hljs-comment">// &#x5339;&#x914D; for in</span>
    <span class="hljs-comment">// &#x5339;&#x914D; v-for=&quot;item, index, key of obj&quot;&#x7684;&#x60C5;&#x51B5;</span>
    <span class="hljs-keyword">if</span> (iteratorMatch[<span class="hljs-number">2</span>]) {
      res.iterator2 = iteratorMatch[<span class="hljs-number">2</span>].trim() <span class="hljs-comment">// &#x5339;&#x914D; for  of</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// &#x6CA1;&#x6709;&#x8FED;&#x4EE3;&#x5668;&#x7684;case</span>
    res.alias = alias
  }
  <span class="hljs-keyword">return</span> res
}
</code></pre>
<h3 id="checkrootconstraints">checkRootConstraints</h3>
<pre><code class="lang-javascript">  <span class="hljs-comment">/**
  * &#x5224;&#x65AD;&#x662F;&#x5426;&#x6709;root &#x6CA1;&#x6709;&#x5C31;&#x8D4B;&#x503C; &#x4E14;&#x5224;&#x65AD;&#x4F5C;&#x4E3A;root&#x7684;&#x5408;&#x6CD5;&#x6027;  &#x4E0D;&#x80FD;&#x6709;v-for&#x6307;&#x4EE4;&#x5728;&#x6839;&#x5143;&#x7D20;&#x51FA;&#x73B0; &#x4E5F;&#x4E0D;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;slot&#x6216;&#x8005;tempoate&#x6807;&#x7B7E;&#x4F5C;&#x4E3A;&#x6839;&#x5143;&#x7D20;
  * */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkRootConstraints</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x4EE5;slot&#x6216;&#x8005;template&#x4F5C;&#x4E3A;&#x6839;&#x5143;&#x7D20;</span>
    <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;slot&apos;</span> || el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
      warnOnce(
        <span class="hljs-string">`Cannot use &lt;<span class="hljs-subst">${el.tag}</span>&gt; as component root element because it may `</span> +
        <span class="hljs-string">&apos;contain multiple nodes.&apos;</span>,
        { start: el.start }
      )
    }
    <span class="hljs-comment">// &#x6839;&#x5143;&#x7D20;&#x4E0D;&#x80FD;&#x6709;v-for&#x6307;&#x4EE4;</span>
    <span class="hljs-keyword">if</span> (el.attrsMap.hasOwnProperty(<span class="hljs-string">&apos;v-for&apos;</span>)) {
      warnOnce(
        <span class="hljs-string">&apos;Cannot use v-for on stateful component root element because &apos;</span> +
        <span class="hljs-string">&apos;it renders multiple elements.&apos;</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]
      )
    }
  }
</code></pre>
<h3 id="processkey">processKey</h3>
<pre><code class="lang-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processKey</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> exp = getBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>)
  <span class="hljs-keyword">if</span> (exp) {
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
      <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
        <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x518D;template&#x6807;&#x7B7E;&#x4E0A;&#x6302;&#x8F7D;key&#x5C5E;&#x6027; &#x5E94;&#x5728;&#x5B9E;&#x9645;&#x5143;&#x7D20;&#x4E0A;&#x6302;&#x8F7D;</span>
        warn(
          <span class="hljs-string">`&lt;template&gt; cannot be keyed. Place the key on real elements instead.`</span>,
          getRawBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>)
        )
      }
      <span class="hljs-comment">// &#x4E0D;&#x80FD;&#x6709;for&#x5FAA;&#x73AF; &#x5219;&#x4E0D;&#x80FD;&#x518D;transition-group&#x4E0B;&#x7684;&#x5B50;&#x7EC4;&#x4EF6;&#x4E0B;&#x653E;&#x7F6E;&#x7D22;&#x5F15;key</span>
      <span class="hljs-keyword">if</span> (el.for) {
        <span class="hljs-keyword">const</span> iterator = el.iterator2 || el.iterator1
        <span class="hljs-keyword">const</span> parent = el.parent
        <span class="hljs-keyword">if</span> (iterator &amp;&amp; iterator === exp &amp;&amp; parent &amp;&amp; parent.tag === <span class="hljs-string">&apos;transition-group&apos;</span>) {
          warn(
            <span class="hljs-string">`Do not use v-for index as key on &lt;transition-group&gt; children, `</span> +
            <span class="hljs-string">`this is the same as not using keys.`</span>,
            getRawBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>),
            <span class="hljs-literal">true</span> <span class="hljs-comment">/* tip */</span>
          )
        }
      }
    }
    el.key = exp
  }
}
</code></pre>
<pre><code class="lang-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processElement</span> (<span class="hljs-params">
  element: ASTElement,
  options: CompilerOptions
</span>) </span>{
  processKey(element)

  <span class="hljs-comment">// determine whether this is a plain element after</span>
  <span class="hljs-comment">// removing structural attributes</span>
  <span class="hljs-comment">// &#x524D;&#x6587;&#x5206;&#x6790; &#x5982;&#x679C;&#x662F;&#x5728;v-pre&#x91CC;&#x9762;  plain = true  </span>
  <span class="hljs-comment">// &#x8FD9;&#x8FB9;&#x662F;&#x518D;&#x6B21;&#x5224;&#x65AD;</span>
  <span class="hljs-comment">// &#x5728;&#x79FB;&#x9664;&#x7ED3;&#x6784;&#x6307;&#x4EE4;&#x540E;&#x662F;&#x5426;&#x8FD8;&#x6709;&#x5176;&#x4ED6;&#x4E00;&#x4E9B;&#x5C5E;&#x6027;&#x4E4B;&#x7C7B;&#x7684;&#x4E1C;&#x897F;  el&#x662F;&#x5426;&#x7EAF;&#x51C0; &#x8FD8;&#x662F;&#x6302;&#x8F7D;&#x4E86;&#x5404;&#x79CD;&#x5C5E;&#x6027;</span>
  element.plain = (
    !element.key &amp;&amp;
    !element.scopedSlots &amp;&amp;
    !element.attrsList.length
  )

  processRef(element)
  processSlotContent(element)
  processSlotOutlet(element)
  processComponent(element)
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; transforms.length; i++) {
    element = transforms[i](element, options) || element
  }
  processAttrs(element)
  <span class="hljs-keyword">return</span> element
}
</code></pre>
<h3 id="checkinfor">checkInFor</h3>
<blockquote>
<p>&#x5FAA;&#x73AF;&#x5224;&#x65AD;&#x662F;&#x5426;&#x5728;for&#x5FAA;&#x73AF;&#x4E2D; &#x627E;parent.for = true</p>
</blockquote>
<pre><code class="lang-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkInFor</span> (<span class="hljs-params">el: ASTElement</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">let</span> parent = el
  <span class="hljs-keyword">while</span> (parent) {
    <span class="hljs-keyword">if</span> (parent.for !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    parent = parent.parent
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}
</code></pre>
<h3 id="processslotcontent">processSlotContent</h3>
<blockquote>
<p>process slot-scope, slot = &apos;xx&apos;</p>
</blockquote>
<pre><code class="lang-javascript">
<span class="hljs-comment">// handle content being passed to a component as slot,</span>
<span class="hljs-comment">// e.g. &lt;template slot=&quot;xxx&quot;&gt;, &lt;div slot-scope=&quot;xxx&quot;&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processSlotContent</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">let</span> slotScope
  <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
    slotScope = getAndRemoveAttr(el, <span class="hljs-string">&apos;scope&apos;</span>)
    <span class="hljs-comment">/* istanbul ignore if */</span>
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; slotScope) {
      warn(
        <span class="hljs-string">`the &quot;scope&quot; attribute for scoped slots have been deprecated and `</span> +
        <span class="hljs-string">`replaced by &quot;slot-scope&quot; since 2.5. The new &quot;slot-scope&quot; attribute `</span> +
        <span class="hljs-string">`can also be used on plain elements in addition to &lt;template&gt; to `</span> +
        <span class="hljs-string">`denote scoped slots.`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;scope&apos;</span>],
        <span class="hljs-literal">true</span>
      )
    }
    <span class="hljs-comment">// &#x7248;&#x672C;&#x517C;&#x5BB9;</span>
    el.slotScope = slotScope || getAndRemoveAttr(el, <span class="hljs-string">&apos;slot-scope&apos;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((slotScope = getAndRemoveAttr(el, <span class="hljs-string">&apos;slot-scope&apos;</span>))) {
    <span class="hljs-comment">/* istanbul ignore if */</span>
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; el.attrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]) {
      <span class="hljs-comment">// v-for&#x6307;&#x4EE4;&#x6700;&#x597D;&#x653E;&#x7F6E;&#x5728;slot-scope&#x4E0A;&#x5C42; &#x4FDD;&#x6301;&#x7EAF;&#x51C0;</span>
      warn(
        <span class="hljs-string">`Ambiguous combined usage of slot-scope and v-for on &lt;<span class="hljs-subst">${el.tag}</span>&gt; `</span> +
        <span class="hljs-string">`(v-for takes higher priority). Use a wrapper &lt;template&gt; for the `</span> +
        <span class="hljs-string">`scoped slot to make it clearer.`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;slot-scope&apos;</span>],
        <span class="hljs-literal">true</span>
      )
    }
    el.slotScope = slotScope
  }

  <span class="hljs-comment">// slot=&quot;xxx&quot;</span>
  <span class="hljs-keyword">const</span> slotTarget = getBindingAttr(el, <span class="hljs-string">&apos;slot&apos;</span>)
  <span class="hljs-keyword">if</span> (slotTarget) {
    <span class="hljs-comment">// &#x53D6;slot&#x540D;&#x79F0;  &#x5982;&#x679C;&#x6CA1;&#x6709; &#x9ED8;&#x8BA4;default  &#x5982;&#x679C; &lt;p slot&gt;show slot&lt;/p&gt;  &#x5219;&#x83B7;&#x53D6;&#x5230;&#x7684;&#x4F4D;slot=&apos;&quot;&quot;&apos;  value = undefined   stringify(undefined) = &apos;&quot;&quot;&apos;</span>
    el.slotTarget = slotTarget === <span class="hljs-string">&apos;&quot;&quot;&apos;</span> ? <span class="hljs-string">&apos;&quot;default&quot;&apos;</span> : slotTarget
    <span class="hljs-comment">// &#x52A8;&#x6001;&#x7ED1;&#x5B9A;</span>
    el.slotTargetDynamic = !!(el.attrsMap[<span class="hljs-string">&apos;:slot&apos;</span>] || el.attrsMap[<span class="hljs-string">&apos;v-bind:slot&apos;</span>])
    <span class="hljs-comment">// preserve slot as an attribute for native shadow DOM compat</span>
    <span class="hljs-comment">// only for non-scoped slots.</span>
    <span class="hljs-comment">// ?????????? &#x8FD9;&#x5757;&#x8FD8;&#x4E0D;&#x5927;&#x660E;&#x767D;  &#x6709;&#x4EC0;&#x4E48;&#x4F5C;&#x7528;&#x8FD8;&#x4E0D;&#x5927;&#x6E05;&#x695A;</span>
    <span class="hljs-comment">// &#x4E0D;&#x662F;template &#x4E14;&#x6CA1;&#x6709;slotScope&#x5C5E;&#x6027;&#x7684;  &#x4FDD;&#x7559;slot&#x5C5E;&#x6027;&#x503C;&#x5728;dom&#x4E2D;</span>
    <span class="hljs-keyword">if</span> (el.tag !== <span class="hljs-string">&apos;template&apos;</span> &amp;&amp; !el.slotScope) {
      addAttr(el, <span class="hljs-string">&apos;slot&apos;</span>, slotTarget, getRawBindingAttr(el, <span class="hljs-string">&apos;slot&apos;</span>))
    }
  }

  <span class="hljs-comment">// 2.6 v-slot syntax</span>
  <span class="hljs-keyword">if</span> (process.env.NEW_SLOT_SYNTAX) {
    <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
      <span class="hljs-comment">// v-slot on &lt;template&gt;</span>
      <span class="hljs-keyword">const</span> slotBinding = getAndRemoveAttrByRegex(el, slotRE)
      <span class="hljs-keyword">if</span> (slotBinding) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          <span class="hljs-keyword">if</span> (el.slotTarget || el.slotScope) {
            <span class="hljs-comment">// &#x7ECF;&#x8FC7;&#x4E0A;&#x9762;&#x89E3;&#x6790;&#x5B58;&#x5728;&#x8FD9;&#x4E24;&#x4E2A;&#x5B57;&#x6BB5;&#x4E86;  &#x63D0;&#x793A;&#x4E0D;&#x80FD;&#x6DF7;&#x7528;</span>
            warn(
              <span class="hljs-string">`Unexpected mixed usage of different slot syntaxes.`</span>,
              el
            )
          }
          <span class="hljs-comment">// template&#x6807;&#x7B7E;&#x4E0A;&#x4F7F;&#x7528;v-slot  &#x53EA;&#x80FD;&#x5728;&#x6839;&#x8282;&#x70B9;&#x4E0A;&#x7528;</span>
          <span class="hljs-comment">// &lt;template&gt;&lt;div v-slot=&quot;xx&quot;&gt;&lt;/div&gt;&lt;/template&gt;  &#x8FD9;&#x6837;&#x660E;&#x663E;&#x4E0D;&#x5408;&#x7406;</span>
          <span class="hljs-keyword">if</span> (el.parent &amp;&amp; !maybeComponent(el.parent)) {
            warn(
              <span class="hljs-string">`&lt;template v-slot&gt; can only appear at the root level inside `</span> +
              <span class="hljs-string">`the receiving the component`</span>,
              el
            )
          }
        }
        <span class="hljs-keyword">const</span> { name, dynamic } = getSlotName(slotBinding)
        el.slotTarget = name
        el.slotTargetDynamic = dynamic
        el.slotScope = slotBinding.value || emptySlotScopeToken <span class="hljs-comment">// force it into a scoped slot for perf</span>
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// v-slot on component, denotes default slot</span>
      <span class="hljs-keyword">const</span> slotBinding = getAndRemoveAttrByRegex(el, slotRE)
      <span class="hljs-keyword">if</span> (slotBinding) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          <span class="hljs-keyword">if</span> (!maybeComponent(el)) {
            warn(
              <span class="hljs-string">`v-slot can only be used on components or &lt;template&gt;.`</span>,
              slotBinding
            )
          }
          <span class="hljs-keyword">if</span> (el.slotScope || el.slotTarget) {
            warn(
              <span class="hljs-string">`Unexpected mixed usage of different slot syntaxes.`</span>,
              el
            )
          }
          <span class="hljs-keyword">if</span> (el.scopedSlots) {
            warn(
              <span class="hljs-string">`To avoid scope ambiguity, the default slot should also use `</span> +
              <span class="hljs-string">`&lt;template&gt; syntax when there are other named slots.`</span>,
              slotBinding
            )
          }
        }
        <span class="hljs-comment">// &#x8FD9;&#x8FB9;&#x8FD8;&#x4E0D;&#x5927;&#x660E;&#x767D;</span>
        <span class="hljs-comment">// add the component&apos;s children to its default slot</span>
        <span class="hljs-keyword">const</span> slots = el.scopedSlots || (el.scopedSlots = {})
        <span class="hljs-keyword">const</span> { name, dynamic } = getSlotName(slotBinding)
        <span class="hljs-keyword">const</span> slotContainer = slots[name] = createASTElement(<span class="hljs-string">&apos;template&apos;</span>, [], el)
        slotContainer.slotTarget = name
        slotContainer.slotTargetDynamic = dynamic
        slotContainer.children = el.children.filter((c: any) =&gt; {
          <span class="hljs-keyword">if</span> (!c.slotScope) {
            c.parent = slotContainer
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
          }
        })
        slotContainer.slotScope = slotBinding.value || emptySlotScopeToken
        <span class="hljs-comment">// remove children as they are returned from scopedSlots now</span>
        el.children = []
        <span class="hljs-comment">// mark el non-plain so data gets generated</span>
        el.plain = <span class="hljs-literal">false</span>
      }
    }
  }
}
</code></pre>
<h3 id="processslotoutlet">processSlotOutlet</h3>
<pre><code class="lang-javascript">
<span class="hljs-comment">// handle &lt;slot/&gt; outlets</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processSlotOutlet</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;slot&apos;</span>) {
    el.slotName = getBindingAttr(el, <span class="hljs-string">&apos;name&apos;</span>)
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; el.key) {
      <span class="hljs-comment">// slot&#x4E0D;&#x53EF;&#x4EE5;&#x8BBE;&#x7F6E;key &#x56E0;&#x4E3A;slot&#x53EF;&#x80FD;&#x653E;&#x5165;&#x591A;&#x4E2A;element&#x4E2D;</span>
      warn(
        <span class="hljs-string">`\`key\` does not work on &lt;slot&gt; because slots are abstract outlets `</span> +
        <span class="hljs-string">`and can possibly expand into multiple elements. `</span> +
        <span class="hljs-string">`Use the key on a wrapping element instead.`</span>,
        getRawBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>)
      )
    }
  }
}
</code></pre>
<h3 id="processcomponent">processComponent</h3>
<pre><code class="lang-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processComponent</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">let</span> binding
  <span class="hljs-keyword">if</span> ((binding = getBindingAttr(el, <span class="hljs-string">&apos;is&apos;</span>))) {
    el.component = binding
  }
  <span class="hljs-keyword">if</span> (getAndRemoveAttr(el, <span class="hljs-string">&apos;inline-template&apos;</span>) != <span class="hljs-literal">null</span>) {
    el.inlineTemplate = <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h3 id="processattrs">processAttrs</h3>
<blockquote>
<p>&#x5173;&#x4E8E;attrs&#x7EC6;&#x5316;&#x5904;&#x7406;</p>
</blockquote>
<pre><code class="lang-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processAttrs</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> list = el.attrsList
  <span class="hljs-keyword">let</span> i, l, name, rawName, value, modifiers, syncGen, isDynamic
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = list.length; i &lt; l; i++) {
    name = rawName = list[i].name
    value = list[i].value
    <span class="hljs-comment">//  &#x5339;&#x914D;&#x7ED1;&#x5B9A;&#x6307;&#x4EE4;  @   v-bind  :   v-on&#x7B49;</span>
    <span class="hljs-keyword">if</span> (dirRE.test(name)) {
      <span class="hljs-comment">// mark element as dynamic</span>
      <span class="hljs-comment">// &#x6807;&#x8BB0;element&#x542B;&#x6709;binding  &#x52A8;&#x6001;element</span>
      el.hasBindings = <span class="hljs-literal">true</span>
      <span class="hljs-comment">// modifiers</span>
      <span class="hljs-comment">// &#x5339;&#x914D;&#x4FEE;&#x9970;&#x7B26; .once  .enter  .passive .prevent&#x7B49;</span>
      modifiers = parseModifiers(name.replace(dirRE, <span class="hljs-string">&apos;&apos;</span>))
      <span class="hljs-comment">// support .foo shorthand syntax for the .prop modifier</span>
      <span class="hljs-comment">// https://github.com/vuejs/vue/issues/7582</span>
      <span class="hljs-comment">// &#x8FD9;&#x91CC;&#x6307;&#x7684;&#x662F;&#x6709;&#x4E2A;&#x8001;&#x5916;&#x63D0;&#x51FA;  .foo=&quot;bar&quot;  &#x8FD9;&#x6837;&#x76F4;&#x63A5;&#x7ED1;&#x5B9A; &#x7B49;&#x540C;&#x4E8E; :foo=&quot;bar&quot;  </span>
      <span class="hljs-keyword">if</span> (process.env.VBIND_PROP_SHORTHAND &amp;&amp; propBindRE.test(name)) {
        (modifiers || (modifiers = {})).prop = <span class="hljs-literal">true</span>
        name = <span class="hljs-string">`.`</span> + name.slice(<span class="hljs-number">1</span>).replace(modifierRE, <span class="hljs-string">&apos;&apos;</span>)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modifiers) {
        name = name.replace(modifierRE, <span class="hljs-string">&apos;&apos;</span>)
      }
      <span class="hljs-comment">// &#x5339;&#x914D;v-bind</span>
      <span class="hljs-keyword">if</span> (bindRE.test(name)) {
        name = name.replace(bindRE, <span class="hljs-string">&apos;&apos;</span>)
        value = parseFilters(value)  <span class="hljs-comment">// &lt;div v-bind:xx=&quot;value | format&quot;&gt;</span>
        <span class="hljs-comment">// _f(&quot;monthFormat&quot;)(_f(&quot;yearFormat&quot;)(createdTime,&apos;arg1&apos;, &apos;arg2&apos;),&apos;yyyy&apos;)</span>
        isDynamic = dynamicArgRE.test(name)
        <span class="hljs-keyword">if</span> (isDynamic) {
          name = name.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)
        }
        <span class="hljs-keyword">if</span> (
          process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp;
          value.trim().length === <span class="hljs-number">0</span>
        ) {
          warn(
            <span class="hljs-string">`The value for a v-bind expression cannot be empty. Found in &quot;v-bind:<span class="hljs-subst">${name}</span>&quot;`</span>
          )
        }
        <span class="hljs-comment">// &#x5982;&#x679C;&#x5B58;&#x5728;&#x4FEE;&#x9970;&#x7B26;</span>
        <span class="hljs-keyword">if</span> (modifiers) {
          <span class="hljs-comment">// .prop&#x4FEE;&#x9970;&#x7B26;  &#x8868;&#x793A;&#x53EA;&#x4F5C;&#x4E3A;attrs  &#x4E0D;&#x4F5C;&#x4E3A;props&#x4F20;&#x9012;&#x7ED9;&#x5B50;&#x7EA7;  &#x4F5C;&#x4E3A;dom&#x89E3;&#x6790; &#x7ED1;&#x5B9A;&#x5728;&#x5143;&#x7D20;&#x4E0A;</span>
          <span class="hljs-keyword">if</span> (modifiers.prop &amp;&amp; !isDynamic) {
            name = camelize(name)
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&apos;innerHtml&apos;</span>) name = <span class="hljs-string">&apos;innerHTML&apos;</span>
          }
          <span class="hljs-comment">// props &#x6216;&#x8005;.prop &#x4F1A;&#x5C06;kebab-case &#x8F6C;&#x5316;&#x4E3A; camelCase  attribute&#x4E0D;&#x4F1A;  &#x90A3;&#x4E48; &#x53EF;&#x4EE5;&#x624B;&#x52A8;&#x6307;&#x5B9A;&#x8FD9;&#x6837;&#x505A;</span>
          <span class="hljs-keyword">if</span> (modifiers.camel &amp;&amp; !isDynamic) {
            name = camelize(name)
          }
          <span class="hljs-comment">// .sync</span>
          <span class="hljs-keyword">if</span> (modifiers.sync) {
            <span class="hljs-comment">// &lt;input :value.sync=&quot;yyy&quot;&gt;todos&lt;/input&gt;</span>
            <span class="hljs-comment">// syncGen: yyy=$event</span>
            syncGen = genAssignmentCode(value, <span class="hljs-string">`$event`</span>)
            <span class="hljs-keyword">if</span> (!isDynamic) {
              addHandler(
                el,
                <span class="hljs-string">`update:<span class="hljs-subst">${camelize(name)}</span>`</span>,
                syncGen,
                <span class="hljs-literal">null</span>,
                <span class="hljs-literal">false</span>,
                warn,
                list[i]
              )
              <span class="hljs-keyword">if</span> (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  <span class="hljs-string">`update:<span class="hljs-subst">${hyphenate(name)}</span>`</span>,
                  syncGen,
                  <span class="hljs-literal">null</span>,
                  <span class="hljs-literal">false</span>,
                  warn,
                  list[i]
                )
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-comment">// handler w/ dynamic event name</span>
              addHandler(
                el,
                <span class="hljs-string">`&quot;update:&quot;+(<span class="hljs-subst">${name}</span>)`</span>,
                syncGen,
                <span class="hljs-literal">null</span>,
                <span class="hljs-literal">false</span>,
                warn,
                list[i],
                <span class="hljs-literal">true</span> <span class="hljs-comment">// dynamic</span>
              )
            }
          }
        }
        <span class="hljs-keyword">if</span> ((modifiers &amp;&amp; modifiers.prop) || (
          !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          <span class="hljs-comment">// pdd: props&#x4E0A;&#x6302;&#x5728;&#x5BF9;&#x8C61;&#x96C6;&#x5408;  el.props = [{}]</span>
          addProp(el, name, value, list[i], isDynamic)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// pdd: attrs&#x4E0A;&#x6302;&#x5728;&#x5BF9;&#x8C61;&#x96C6;&#x5408;  el.attrs = [{}]</span>
          addAttr(el, name, value, list[i], isDynamic)
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onRE.test(name)) {
        name = name.replace(onRE, <span class="hljs-string">&apos;&apos;</span>)
        isDynamic = dynamicArgRE.test(name)
        <span class="hljs-keyword">if</span> (isDynamic) {
          name = name.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)
        }
        addHandler(el, name, value, modifiers, <span class="hljs-literal">false</span>, warn, list[i], isDynamic)
      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// normal directives</span>
        name = name.replace(dirRE, <span class="hljs-string">&apos;&apos;</span>)
        <span class="hljs-comment">// parse arg</span>
        <span class="hljs-keyword">const</span> argMatch = name.match(argRE)
        <span class="hljs-keyword">let</span> arg = argMatch &amp;&amp; argMatch[<span class="hljs-number">1</span>]
        isDynamic = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> (arg) {
          name = name.slice(<span class="hljs-number">0</span>, -(arg.length + <span class="hljs-number">1</span>))
          <span class="hljs-keyword">if</span> (dynamicArgRE.test(arg)) {
            arg = arg.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)
            isDynamic = <span class="hljs-literal">true</span>
          }
        }
        <span class="hljs-comment">// pdd: &#x6307;&#x4EE4;&#x5904;&#x7406;</span>
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i])
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; name === <span class="hljs-string">&apos;model&apos;</span>) {
          checkForAliasModel(el, value)
        }
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// literal attribute</span>
      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
        <span class="hljs-keyword">const</span> res = parseText(value, delimiters)
        <span class="hljs-keyword">if</span> (res) {
          warn(
            <span class="hljs-string">`<span class="hljs-subst">${name}</span>=&quot;<span class="hljs-subst">${value}</span>&quot;: `</span> +
            <span class="hljs-string">&apos;Interpolation inside attributes has been removed. &apos;</span> +
            <span class="hljs-string">&apos;Use v-bind or the colon shorthand instead. For example, &apos;</span> +
            <span class="hljs-string">&apos;instead of &lt;div id=&quot;{{ val }}&quot;&gt;, use &lt;div :id=&quot;val&quot;&gt;.&apos;</span>,
            list[i]
          )
        }
      }
      addAttr(el, name, <span class="hljs-built_in">JSON</span>.stringify(value), list[i])
      <span class="hljs-comment">// #6887 firefox doesn&apos;t update muted state if set via attribute</span>
      <span class="hljs-comment">// even immediately after element creation</span>
      <span class="hljs-keyword">if</span> (!el.component &amp;&amp;
          name === <span class="hljs-string">&apos;muted&apos;</span> &amp;&amp;
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, <span class="hljs-string">&apos;true&apos;</span>, list[i])
      }
    }
  }
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../" class="navigation navigation-prev " aria-label="Previous page: compiler">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="./" class="navigation navigation-next " aria-label="Next page: index">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"parser","level":"1.2.1","depth":2,"next":{"title":"index","level":"1.2.1.1","depth":3,"path":"compiler/parser/index.md","ref":"compiler/parser/index.md","articles":[]},"previous":{"title":"compiler","level":"1.2","depth":1,"path":"compiler/index.md","ref":"compiler/index.md","articles":[{"title":"parser","level":"1.2.1","depth":2,"path":"compiler/parser/index.md","ref":"compiler/parser/index.md","articles":[{"title":"index","level":"1.2.1.1","depth":3,"path":"compiler/parser/index.md","ref":"compiler/parser/index.md","articles":[]},{"title":"html-parser","level":"1.2.1.2","depth":3,"path":"compiler/parser/html-parser.md","ref":"compiler/parser/html-parser.md","articles":[]},{"title":"filter-parser","level":"1.2.1.3","depth":3,"path":"compiler/parser/filter-parser.md","ref":"compiler/parser/filter-parser.md","articles":[]}]},{"title":"directives","level":"1.2.2","depth":2,"path":"compiler/directives/index.md","ref":"compiler/directives/index.md","articles":[{"title":"model","level":"1.2.2.1","depth":3,"path":"compiler/directives/model.md","ref":"compiler/directives/model.md","articles":[]}]},{"title":"helpers","level":"1.2.3","depth":2,"path":"compiler/helpers.md","ref":"compiler/helpers.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["expandable-chapters","favicon"],"styles":{"website":"./styles/website.css"},"pluginsConfig":{"favicon":{"shortcut":"./source/images/favicon.jpg","bookmark":"./source/images/favicon.jpg","appleTouch":"./source/images/apple-touch-icon.jpg","appleTouchMore":{"120x120":"./source/images/apple-touch-icon.jpg","180x180":"./source/images/apple-touch-icon.jpg"}},"expandable-chapters":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Blankj","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Blankj's Glory","language":"zh-hans","gitbook":"3.2.3","description":"select * from learn"},"file":{"path":"compiler/parser/index.md","mtime":"2019-09-20T13:18:44.596Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-20T13:29:59.978Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

